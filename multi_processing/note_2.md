1. Linux上的**进程调度算法**
   - 进程调度：在操作系统中调度是指一种资源分配。
   - 调度算法是指：根据系统的资源分配策略所规定的资源分配算法。
   - **先来先去服务**：
     - 优点：有利于长作业以及CPU繁忙的作业
     - 缺点：不利于短作业以及I/O繁忙的作业
   - **短作业优先调度算法**：
     - 优点：比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；提高系统的吞吐量；
     - 缺点：对长作业非常不利，可能长时间得不到执行；未能依据作业的紧迫程度来划分执行的优先级；难以准确估计作业（进程）的执行时间，从而影响调度性能。
   - **时间片轮转法**
   - **多级反馈队列算法**：设置多个就绪队列，分别赋予不同的优先级，如逐级降低，队列1的优先级最高。每个队列执行时间片的长度也不同，规定优先级越低则时间片越长，如逐级加倍。新进程进入内存后，先投入队列1的末尾，按FCFS算法调度；若按队列1一个时间片未能执行完，则降低投入到队列2的末尾，同样按FCFS算法调度；如此下去，降低到最后的队列，则按“时间片轮转”算法调度直到完成。
     - 优点：为提高系统吞吐量和缩短平均周转时间而照顾短进程。为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程。不必估计进程的执行时间，动态调节
2. **进程**是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的 一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是 基本的分配单元，也是基本的执行单元。
3. - **并行(parallel)**：指在同一时刻，有多条指令在多个处理器上同时执行。
   - **并发(concurrency)**：指在同一时刻只能有一条指令执行，但多个进程指令被快速的 轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的， 只是把时间分成若干段，使多个进程快速交替的执行
4. 为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分 配一个 PCB(Processing Control Block)**进程控制块**，维护进程相关的信息， Linux 内核的进程控制块是 task_struct 结构体。
5. **进程状态**分为三个基本状态，即就绪态，运行态，阻塞态。在五态模型 中，进程分为新建态、就绪态，运行态，阻塞态，终止态。

   - 每个进程都由进程号来标识，其类型为 pid_t（整型），进程号的范围：0～32767。 进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。
   -  任何进程（除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程， 对应的进程号称为父进程号（PPID）。
   - 进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各 种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当 前的进程组号。
6. **exec 函数族**的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的 内容，换句话说，就是在调用进程内部执行一个可执行文件。
7. exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据 段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样， 颇有些神似“三十六计”中的“金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵 魂。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。
8. - 父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为**孤儿进程**。

   - 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init  进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束 了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。
   -  因此孤儿进程并不会有什么危害。
   - 每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法 自己释放掉，需要父进程去释放。
   - 进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成**僵尸 （Zombie）进程**。
   - 僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait()  或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用， 但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进 程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。
   - 在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内 存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息 （包括进程号、退出状态、运行时间等）。
   - 父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。
9. 进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间 的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要**进程间通信( IPC：Inter Processes Communication )**。
10. 进程间通信的目的：数据传输、通知事件、资源共享、进程控制
11. Linux进程间通信的方式：**匿名管道、有名管道、信号、消息队列、共享内存、信号量、Socket**
12. 管道也叫**匿名管道**：
    - 管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的 操作系统大小不一定相同。
    - 管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体， 但不存储数据。可以按照操作文件的方式对管道进行操作。
    - 一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据 的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。
    - 通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺 序是完全一样的。
    - 在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。
    - 从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写 更多的数据，在管道中无法使用 lseek() 来随机的访问数据。
    - **匿名管道只能在具有公共祖先的进程**（父进程与子进程，或者两个兄弟进程，具有亲缘 关系）**之间使用。**
13. 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提 出了**有名管道（FIFO）**，也叫命名管道、FIFO文件。
    - 有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO  的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样 即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此 通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。
    - 一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的 I/O系统调用了（如read()、write()和close()）。与管道一样，FIFO 也有一 个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的 名称也由此而来：先入先出。
14.  **有名管道（FIFO)和匿名管道（pipe）**有一些特点是相同的，不一样的地方在于： 
    -  FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。 
    - 当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。
    - FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。
15. **内存映射**：是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。
16. **信号**是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也 称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号 可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。
    - 特点：简单、不能携带大量信息、满足某个特定条件才发送、优先级比较高
    - 信号的五种默认处理动作：终止进程、当前进程忽略掉这个信号、终止进程并生成一个Core文件、暂停当前进程、继续执行当前被暂停的进程
    - 信号的几种状态：产生、未决、递达
    - **SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。**
    - 在 PCB 中有两个非常重要的信号集。一个称之为 “**阻塞信号集**” ，另一个称之为 “**未决信号集**” 。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我 们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数 来对 PCB 中的这两个信号集进行修改。
    - 信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。
    - 信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。
    - 信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号， 所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。
17. **共享内存**允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于 一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介 入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其 他所有共享同一个段的进程可用。
    - 与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据 从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。
    - **使用步骤**
      - 调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其 他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。 
      -  使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。 
      - 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存， 程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间 中该共享内存段的起点的指针。 
      - 调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存 了。这一步是可选的，并且在进程终止时会自动完成这一步。 
      - 调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之 后内存段才会销毁。只有一个进程需要执行这一步。
18. **守护进程**
    - **进程组和会话**在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合， 会话是一组相关进程组的集合。进程组和会话是为支持 shell 作业控制而定义的抽 象概念，用户通过 shell 能够交互式地在前台或后台运行命令。
    - 一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终 端设备时被建立。一个终端最多可能会成为一个会话的控制终端。
    - 在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为 后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终 端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。
    - **守护进程**（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周 期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。特征为：
      - 生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。
      -  它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进 程自动生成任何控制信号以及终端相关的信号
    - Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd， Web 服务器 httpd 等。
    - **创建步骤**
      - 执行一个 fork()，之后父进程退出，子进程继续执行。 
      - 子进程调用 setsid() 开启一个新会话。 
      - 清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。 
      - 修改进程的当前工作目录，通常会改为根目录（/）。 
      - 关闭守护进程从其父进程继承而来的所有打开着的文件描述符。 
      - 在关闭了文件描述符0、1、2之后，守护进程通常会打开/dev/null 并使用dup2()  使所有这些描述符指向这个设备。 
      - 核心业务逻辑

