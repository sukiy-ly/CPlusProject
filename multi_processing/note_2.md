1. Linux上的**进程调度算法**：

2. **进程**是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的 一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是 基本的分配单元，也是基本的执行单元。

3. - **并行(parallel)**：指在同一时刻，有多条指令在多个处理器上同时执行。
   - **并发(concurrency)**：指在同一时刻只能有一条指令执行，但多个进程指令被快速的 轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的， 只是把时间分成若干段，使多个进程快速交替的执行

4. 为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分 配一个 PCB(Processing Control Block)**进程控制块**，维护进程相关的信息， Linux 内核的进程控制块是 task_struct 结构体。

5. **进程状态**分为三个基本状态，即就绪态，运行态，阻塞态。在五态模型 中，进程分为新建态、就绪态，运行态，阻塞态，终止态。

   - 每个进程都由进程号来标识，其类型为 pid_t（整型），进程号的范围：0～32767。 进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。
   -  任何进程（除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程， 对应的进程号称为父进程号（PPID）。
   - 进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各 种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当 前的进程组号。

6. **exec 函数族**的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的 内容，换句话说，就是在调用进程内部执行一个可执行文件。

7. exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据 段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样， 颇有些神似“三十六计”中的“金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵 魂。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。

8. - 父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为**孤儿进程**。

   - 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init  进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束 了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。
   -  因此孤儿进程并不会有什么危害。
   - 每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法 自己释放掉，需要父进程去释放。
   - 进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成**僵尸 （Zombie）进程**。
   - 僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait()  或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用， 但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进 程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。
   - 在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内 存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息 （包括进程号、退出状态、运行时间等）。
   - 父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。

9. 

